import { isRegistryModule, ProviderSchema } from "@cdktf/provider-generator";
export { setLogger } from "./utils";
export declare const CODE_MARKER = "// define resources here";
export declare function getParsedHcl(hcl: string): Promise<{
    module?: Record<string, import("zod/lib/src/helpers/objectUtil").objectUtil.Flatten<{
        source: string;
    } & {
        [k: string]: any;
    }>[]> | undefined;
    data?: Record<string, Record<string, Record<string, any>[]>> | undefined;
    terraform?: {
        required_version?: string | undefined;
        required_providers?: Record<string, string | {
            source?: string | undefined;
            version?: string | undefined;
        }>[] | undefined;
        backend?: Record<string, Record<string, any>[]> | undefined;
    }[] | undefined;
    provider?: Record<string, Record<string, any>[]> | undefined;
    resource?: Record<string, Record<string, Record<string, any>[]>> | undefined;
    locals?: Record<string, any>[] | undefined;
    variable?: Record<string, {
        type?: string | undefined;
        default?: any;
        description?: string | undefined;
        validation?: Record<string, {
            condition?: any;
            error_message: string;
        }>[] | undefined;
        nullable?: boolean | undefined;
        sensitive?: boolean | undefined;
    }[]> | undefined;
    output?: Record<string, {
        value?: any;
        description?: string | undefined;
        sensitive?: boolean | undefined;
        depends_on?: string | undefined;
    }[]> | undefined;
}>;
export declare function parseProviderRequirements(hcl: string): Promise<Record<string, string>>;
export declare function convertToTypescript(hcl: string, providerSchema: ProviderSchema): Promise<{
    all: string;
    imports: string;
    code: string;
    providers: string[];
    modules: string[];
    stats: {
        numberOfModules: number;
        numberOfProviders: number;
        resources: Record<string, Record<string, number>>;
        data: Record<string, Record<string, number>>;
        convertedLines: number;
    };
}>;
declare type File = {
    contents: string;
    fileName: string;
};
declare const translations: {
    typescript: (file: File) => string;
    python: (file: File) => string;
    java: (file: File) => string;
    csharp: (file: File) => string;
};
declare type ConvertOptions = {
    language: keyof typeof translations;
    providerSchema: ProviderSchema;
};
export declare function convert(hcl: string, { language, providerSchema }: ConvertOptions): Promise<{
    all: string;
    imports: string;
    code: string;
    stats: {
        language: "typescript" | "python" | "java" | "csharp";
        numberOfModules: number;
        numberOfProviders: number;
        resources: Record<string, Record<string, number>>;
        data: Record<string, Record<string, number>>;
        convertedLines: number;
    };
    providers: string[];
    modules: string[];
}>;
export declare function getTerraformConfigFromDir(importPath: string): string;
declare type CdktfJson = Record<string, unknown> & {
    terraformProviders: any[];
    terraformModules: any[];
};
export declare function convertProject(combinedHcl: string, { language, providerSchema }: ConvertOptions): Promise<{
    code: (inputMainFile: string) => string;
    cdktfJson: (inputCdktfJson: CdktfJson) => {
        [x: string]: unknown;
        terraformProviders: any[];
        terraformModules: any[];
    };
    stats: {
        language: "typescript" | "python" | "java" | "csharp";
        numberOfModules: number;
        numberOfProviders: number;
        resources: Record<string, Record<string, number>>;
        data: Record<string, Record<string, number>>;
        convertedLines: number;
    };
}>;
export { isRegistryModule };
