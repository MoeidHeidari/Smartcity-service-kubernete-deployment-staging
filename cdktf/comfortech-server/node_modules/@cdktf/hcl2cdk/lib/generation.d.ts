import * as t from "@babel/types";
import { DirectedGraph } from "graphology";
import { TerraformResourceBlock, Scope } from "./types";
import { Resource, TerraformConfig, Module, Provider, Variable, Output } from "./schema";
export declare const valueToTs: (scope: Scope, item: TerraformResourceBlock, path: string, nodeIds: string[], scopedIds?: string[], isModule?: boolean) => Promise<t.Expression>;
export declare function backendToExpression(scope: Scope, tf: TerraformConfig["backend"], nodeIds: string[]): Promise<t.Statement[]>;
export declare function resource(scope: Scope, type: string, key: string, id: string, item: Resource, graph: DirectedGraph): Promise<t.Statement[]>;
export declare function output(scope: Scope, key: string, _id: string, item: Output, graph: DirectedGraph): Promise<(t.ExpressionStatement | t.VariableDeclaration)[]>;
export declare function variable(scope: Scope, key: string, id: string, item: Variable, graph: DirectedGraph): Promise<(t.ExpressionStatement | t.VariableDeclaration)[]>;
export declare function local(scope: Scope, key: string, id: string, item: TerraformResourceBlock, graph: DirectedGraph): Promise<t.VariableDeclaration[]>;
export declare function modules(scope: Scope, key: string, id: string, item: Module, graph: DirectedGraph): Promise<(t.ExpressionStatement | t.VariableDeclaration)[]>;
export declare function provider(scope: Scope, key: string, id: string, item: Provider[0], graph: DirectedGraph): Promise<(t.ExpressionStatement | t.VariableDeclaration)[]>;
export declare const cdktfImport: t.Statement;
export declare const providerImports: (providers: string[]) => t.Statement[];
export declare const moduleImports: (modules: Record<string, Module> | undefined) => t.Statement[];
export declare function gen(statements: t.Statement[]): Promise<string>;
