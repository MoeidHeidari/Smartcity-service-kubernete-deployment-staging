"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withTemporaryDirectory = exports.DUMMY_JSII_CONFIG = exports.testSnippetLocation = exports.TestJsiiModule = void 0;
const spec_1 = require("@jsii/spec");
const fs = require("fs-extra");
const jsii_1 = require("jsii");
const os = require("os");
const path = require("path");
const lib_1 = require("../lib");
/**
 * Compile a jsii module from source, and produce an environment in which it is available as a module
 */
class TestJsiiModule {
    constructor(assembly, workspace, compressAssembly) {
        this.assembly = assembly;
        this.workspace = workspace;
        this.compressAssembly = compressAssembly;
        this.moduleDirectory = workspace.dependencyDir(assembly.name);
        this.workspaceDirectory = workspace.rootDirectory;
    }
    static fromSource(source, packageInfo, options = {}) {
        const asm = (0, jsii_1.compileJsiiForTest)(source, {
            packageJson: packageInfo,
            compressAssembly: options.compressAssembly,
        });
        const ws = jsii_1.TestWorkspace.create();
        ws.addDependency(asm);
        return new TestJsiiModule(asm.assembly, ws, asm.compressAssembly === true);
    }
    /**
     * Make a snippet translator for the given source w.r.t this compiled assembly
     */
    successfullyCompile(source) {
        const location = testSnippetLocation('testutil');
        const snippet = (0, lib_1.typeScriptSnippetFromCompleteSource)(source, location, false, {
            [lib_1.SnippetParameters.$COMPILATION_DIRECTORY]: this.workspaceDirectory,
        });
        const ret = new lib_1.SnippetTranslator(snippet, {
            includeCompilerDiagnostics: true,
        });
        if (ret.compileDiagnostics.length > 0) {
            for (const diag of ret.compileDiagnostics.map(lib_1.rosettaDiagFromTypescript)) {
                console.error(diag.formattedMessage);
            }
            throw new Error('Compilation failures');
        }
        return ret;
    }
    translateHere(source) {
        const location = testSnippetLocation('testutil');
        const snip = (0, lib_1.typeScriptSnippetFromCompleteSource)(source.trimLeft(), location, true, {
            [lib_1.SnippetParameters.$COMPILATION_DIRECTORY]: this.workspaceDirectory,
        });
        const trans = new lib_1.Translator(true);
        const ret = trans.translate(snip);
        if (trans.diagnostics.length > 0) {
            for (const diag of trans.diagnostics) {
                console.error(diag.formattedMessage);
            }
            throw new Error('Compilation failures');
        }
        return ret;
    }
    /**
     * Update the file to reflect the latest changes to the assembly object.
     */
    updateAssembly() {
        (0, spec_1.writeAssembly)(this.moduleDirectory, this.assembly, { compress: this.compressAssembly });
    }
    cleanup() {
        this.workspace.cleanup();
    }
}
exports.TestJsiiModule = TestJsiiModule;
function testSnippetLocation(fileName) {
    return { api: { api: 'file', fileName }, field: { field: 'example' } };
}
exports.testSnippetLocation = testSnippetLocation;
exports.DUMMY_JSII_CONFIG = {
    targets: {
        dotnet: {
            namespace: 'Example.Test.Demo',
            packageId: 'Example.Test.Demo',
        },
        go: { moduleName: 'example.test/demo' },
        java: {
            maven: {
                groupId: 'example.test',
                artifactId: 'demo',
            },
            package: 'example.test.demo',
        },
        python: {
            distName: 'example-test.demo',
            module: 'example_test_demo',
        },
    },
};
async function withTemporaryDirectory(callback) {
    const tmpdir = fs.mkdtempSync(path.join(os.tmpdir(), path.basename(__filename)));
    return callback(tmpdir).finally(() => fs.removeSync(tmpdir));
}
exports.withTemporaryDirectory = withTemporaryDirectory;
//# sourceMappingURL=testutil.js.map